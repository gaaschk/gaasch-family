// prisma/schema.final.prisma
//
// FINAL multi-tenant schema.
// Copy this file to schema.prisma after running scripts/migrate-to-multi-tenant.ts,
// then run: npm run db:migrate && npm run db:generate
//
// Changes from intermediate schema:
//   - Person.treeId: String? → String (NOT NULL)
//   - Person.id: adds @default(cuid()) (existing CUIDs are preserved)
//   - Person: adds @@unique([treeId, gedcomId])
//   - Family: same as Person
//   - Setting: changes PK from key→id, adds @@unique([treeId, key]), treeId NOT NULL
//   - AuditLog.treeId remains nullable (historical records may not have a tree)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// ── Auth.js required models ──────────────────────────────────────────────────

model Account {
  id                String  @id @default(cuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime? @map("email_verified")
  image         String?
  role          String    @default("pending")
  password      String?
  tokenVersion  Int       @default(0)
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  accounts    Account[]
  sessions    Session[]
  auditLogs   AuditLog[]
  ownedTrees  Tree[]       @relation("TreeOwner")
  treeMembers TreeMember[]
  fsToken     FamilySearchToken?
  geniToken   GeniToken?

  @@map("users")
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// ── Multi-tenancy models ──────────────────────────────────────────────────────

model Tree {
  id          String   @id @default(cuid())
  slug        String   @unique
  name        String
  description String?
  ownerId     String   @map("owner_id")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  owner     User                @relation("TreeOwner", fields: [ownerId], references: [id])
  members   TreeMember[]
  invites   TreeInvite[]
  people    Person[]
  families  Family[]
  settings  Setting[]
  auditLogs AuditLog[]
  fsMatches      FamilySearchMatch[]
  lineageStories LineageStory[]

  @@map("trees")
}

model TreeMember {
  id       String   @id @default(cuid())
  treeId   String   @map("tree_id")
  userId   String   @map("user_id")
  role     String   @default("viewer")
  joinedAt DateTime @default(now()) @map("joined_at")

  tree Tree @relation(fields: [treeId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([treeId, userId])
  @@map("tree_members")
}

model TreeInvite {
  id         String    @id @default(cuid())
  treeId     String    @map("tree_id")
  email      String
  role       String    @default("viewer")
  token      String    @unique @default(cuid())
  invitedBy  String    @map("invited_by")
  expiresAt  DateTime  @map("expires_at")
  acceptedAt DateTime? @map("accepted_at")
  createdAt  DateTime  @default(now()) @map("created_at")
  lastSentAt DateTime  @default(now()) @map("last_sent_at")
  sentCount  Int       @default(1)     @map("sent_count")

  tree Tree @relation(fields: [treeId], references: [id], onDelete: Cascade)

  @@map("tree_invites")
}

// ── Family history models ─────────────────────────────────────────────────────

model Person {
  id          String   @id @default(cuid())
  treeId      String   @map("tree_id")
  gedcomId    String?  @map("gedcom_id")
  name        String
  sex         String?
  birthDate   String?  @map("birth_date")
  birthPlace  String?  @map("birth_place")
  deathDate   String?  @map("death_date")
  deathPlace  String?  @map("death_place")
  burialPlace String?  @map("burial_place")
  burialDate  String?  @map("burial_date")
  occupation  String?
  notes       String?
  narrative   String?
  fsPid       String?  @map("fs_pid")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  tree      Tree                @relation(fields: [treeId], references: [id], onDelete: Cascade)
  asHusband Family[]            @relation("FamilyHusband")
  asWife    Family[]            @relation("FamilyWife")
  childIn   FamilyChild[]
  fsMatches FamilySearchMatch[]

  @@unique([treeId, gedcomId])
  @@map("people")
}

model FamilySearchMatch {
  id        String   @id @default(cuid())
  personId  String   @map("person_id")
  treeId    String   @map("tree_id")
  source    String   @default("familysearch") @map("source")
  fsPid     String   @map("fs_pid")
  score     Float
  fsData    String   @map("fs_data")   // JSON: FsPersonSummary
  status    String   @default("pending") // pending | accepted | rejected
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  person Person @relation(fields: [personId], references: [id], onDelete: Cascade)
  tree   Tree   @relation(fields: [treeId], references: [id], onDelete: Cascade)

  @@unique([personId, source, fsPid])
  @@map("familysearch_matches")
}

model Family {
  id        String   @id @default(cuid())
  treeId    String   @map("tree_id")
  gedcomId  String?  @map("gedcom_id")
  husband   Person?  @relation("FamilyHusband", fields: [husbId], references: [id], onDelete: SetNull)
  husbId    String?  @map("husb_id")
  wife      Person?  @relation("FamilyWife", fields: [wifeId], references: [id], onDelete: SetNull)
  wifeId    String?  @map("wife_id")
  marrDate  String?  @map("marr_date")
  marrPlace String?  @map("marr_place")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  tree     Tree         @relation(fields: [treeId], references: [id], onDelete: Cascade)
  children FamilyChild[]

  @@unique([treeId, gedcomId])
  @@map("families")
}

model FamilyChild {
  family   Family @relation(fields: [familyId], references: [id], onDelete: Cascade)
  familyId String @map("family_id")
  person   Person @relation(fields: [personId], references: [id], onDelete: Cascade)
  personId String @map("person_id")

  @@id([familyId, personId])
  @@map("family_children")
}

model Setting {
  id        String   @id @default(cuid())
  treeId    String   @map("tree_id")
  key       String
  value     String
  updatedAt DateTime @updatedAt @map("updated_at")

  tree Tree @relation(fields: [treeId], references: [id], onDelete: Cascade)

  @@unique([treeId, key])
  @@map("settings")
}

model FamilySearchToken {
  id           String   @id @default(cuid())
  userId       String   @unique @map("user_id")
  accessToken  String   @map("access_token")
  refreshToken String?  @map("refresh_token")
  expiresAt    DateTime @map("expires_at")
  displayName  String?  @map("display_name")
  fsCisId      String?  @map("fs_cis_id")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("familysearch_tokens")
}

model GeniToken {
  id           String   @id @default(cuid())
  userId       String   @unique @map("user_id")
  accessToken  String   @map("access_token")
  refreshToken String?  @map("refresh_token")
  expiresAt    DateTime @map("expires_at")
  displayName  String?  @map("display_name")
  geniId       String?  @map("geni_id")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("geni_tokens")
}

model SystemSetting {
  key       String   @id
  value     String
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("system_settings")
}

model LineageStory {
  id           String   @id @default(cuid())
  treeId       String   @map("tree_id")
  personIdsKey String   @map("person_ids_key")
  html         String
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  tree Tree @relation(fields: [treeId], references: [id], onDelete: Cascade)

  @@unique([treeId, personIdsKey])
  @@map("lineage_stories")
}

model AuditLog {
  id        String   @id @default(cuid())
  tableName String   @map("table_name")
  recordId  String   @map("record_id")
  action    String
  oldData   String?  @map("old_data")
  newData   String?  @map("new_data")
  treeId    String?  @map("tree_id")
  user      User?    @relation(fields: [userId], references: [id])
  userId    String?  @map("user_id")
  createdAt DateTime @default(now()) @map("created_at")

  tree Tree? @relation(fields: [treeId], references: [id])

  @@map("audit_log")
}
